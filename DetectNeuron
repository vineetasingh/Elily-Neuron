  #include <iostream>     // std::cout
#include <algorithm>    // std::min_element, std::max_element
#include "opencv2/core/core.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include <string>
#include<conio.h>
#include <opencv/cv.h>
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/features2d/features2d.hpp"
#include <fstream>
#include "opencv2/imgproc/imgproc.hpp"
#include <iostream>
#include<vector>
#include "opencv2/opencv.hpp "



using namespace cv;
using namespace std;
int thresh = 1;
int gauKsize = 11;
int maxGauKsize = 21;
void filterHessian(Mat image)
{
	int co = 0;
	Mat org = imread("Testrun.tif");
	cv::Mat dXX, dYY, dXY;

	cv::Sobel(image, dXX, CV_32F, 2, 0);
	cv::Sobel(image, dYY, CV_32F, 0, 2);
	cv::Sobel(image, dXY, CV_32F, 1, 1);
	//eigen(src, destination);

	cv::Mat gau = cv::getGaussianKernel(gauKsize, -1, CV_32F);

	cv::sepFilter2D(dXX, dXX, CV_32F, gau.t(), gau);
	cv::sepFilter2D(dYY, dYY, CV_32F, gau.t(), gau);
	cv::sepFilter2D(dXY, dXY, CV_32F, gau.t(), gau);

	std::vector<float> eigenvalues(2);
	cout << dYY.at<float>(Point(2,2)) << endl;
	cv::Mat matrix(2, 2, CV_32F);
	for (int i = 0; i < image.rows; i++) {
		for (int j = 0; j < image.cols; j++) {
			matrix.at<float>(Point(0, 0)) = dXX.at<float>(Point(j,i));
			matrix.at<float>(Point(1, 1)) = dYY.at<float>(Point(j, i));
			matrix.at<float>(Point(0, 1))=dXY.at<float>(Point(j, i));
			matrix.at<float>(Point(1, 0)) = dXY.at<float>(Point(j, i));
			eigen(matrix, eigenvalues);
			float ratio = ((abs(eigenvalues[0]) > abs(eigenvalues[1])) ?
				eigenvalues[0] / eigenvalues[1] : eigenvalues[1] / eigenvalues[0]);
			if (ratio > 0.0f && ratio <= 1.1) {
				co++;
				circle(org, cv::Point(j,i), 1, cv::Scalar(0, 125, 255), 2, 8, 0);
			}
		}
	}
	cout << co << endl;
	imshow("show", org);
}
int main()
{
	Mat im = imread("Testrun.tif");
	cvtColor(im, im, CV_BGR2GRAY);
	//cv::inRange(im, cv::Scalar(0, 100, 0), cv::Scalar(130, 255, 130), thresh_img);
	filterHessian(im);

	waitKey(0);
	
	return 0;


}
